# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rctestpkg/MPC_LKRequest.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class MPC_LKRequest(genpy.Message):
  _md5sum = "a13af95f0a28e8da29d99752aca488a9"
  _type = "rctestpkg/MPC_LKRequest"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """float64 y0
float64 v0
float64 p0
float64 r0
float64 s0
float64 wy
float64 wv
float64 wp
float64 wr
float64 ws
float64 y_max
float64 y_min
float64 v_max
float64 p_max
float64 r_max
float64 s_max
float64[] A
float64[] B
float64[] E
float64[] rd
"""
  __slots__ = ['y0','v0','p0','r0','s0','wy','wv','wp','wr','ws','y_max','y_min','v_max','p_max','r_max','s_max','A','B','E','rd']
  _slot_types = ['float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64[]','float64[]','float64[]','float64[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       y0,v0,p0,r0,s0,wy,wv,wp,wr,ws,y_max,y_min,v_max,p_max,r_max,s_max,A,B,E,rd

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(MPC_LKRequest, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.y0 is None:
        self.y0 = 0.
      if self.v0 is None:
        self.v0 = 0.
      if self.p0 is None:
        self.p0 = 0.
      if self.r0 is None:
        self.r0 = 0.
      if self.s0 is None:
        self.s0 = 0.
      if self.wy is None:
        self.wy = 0.
      if self.wv is None:
        self.wv = 0.
      if self.wp is None:
        self.wp = 0.
      if self.wr is None:
        self.wr = 0.
      if self.ws is None:
        self.ws = 0.
      if self.y_max is None:
        self.y_max = 0.
      if self.y_min is None:
        self.y_min = 0.
      if self.v_max is None:
        self.v_max = 0.
      if self.p_max is None:
        self.p_max = 0.
      if self.r_max is None:
        self.r_max = 0.
      if self.s_max is None:
        self.s_max = 0.
      if self.A is None:
        self.A = []
      if self.B is None:
        self.B = []
      if self.E is None:
        self.E = []
      if self.rd is None:
        self.rd = []
    else:
      self.y0 = 0.
      self.v0 = 0.
      self.p0 = 0.
      self.r0 = 0.
      self.s0 = 0.
      self.wy = 0.
      self.wv = 0.
      self.wp = 0.
      self.wr = 0.
      self.ws = 0.
      self.y_max = 0.
      self.y_min = 0.
      self.v_max = 0.
      self.p_max = 0.
      self.r_max = 0.
      self.s_max = 0.
      self.A = []
      self.B = []
      self.E = []
      self.rd = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_16d.pack(_x.y0, _x.v0, _x.p0, _x.r0, _x.s0, _x.wy, _x.wv, _x.wp, _x.wr, _x.ws, _x.y_max, _x.y_min, _x.v_max, _x.p_max, _x.r_max, _x.s_max))
      length = len(self.A)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.A))
      length = len(self.B)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.B))
      length = len(self.E)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.E))
      length = len(self.rd)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.rd))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      _x = self
      start = end
      end += 128
      (_x.y0, _x.v0, _x.p0, _x.r0, _x.s0, _x.wy, _x.wv, _x.wp, _x.wr, _x.ws, _x.y_max, _x.y_min, _x.v_max, _x.p_max, _x.r_max, _x.s_max,) = _struct_16d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.A = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.B = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.E = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.rd = struct.unpack(pattern, str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_16d.pack(_x.y0, _x.v0, _x.p0, _x.r0, _x.s0, _x.wy, _x.wv, _x.wp, _x.wr, _x.ws, _x.y_max, _x.y_min, _x.v_max, _x.p_max, _x.r_max, _x.s_max))
      length = len(self.A)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.A.tostring())
      length = len(self.B)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.B.tostring())
      length = len(self.E)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.E.tostring())
      length = len(self.rd)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.rd.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      _x = self
      start = end
      end += 128
      (_x.y0, _x.v0, _x.p0, _x.r0, _x.s0, _x.wy, _x.wv, _x.wp, _x.wr, _x.ws, _x.y_max, _x.y_min, _x.v_max, _x.p_max, _x.r_max, _x.s_max,) = _struct_16d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.A = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.B = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.E = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.rd = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_16d = struct.Struct("<16d")
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rctestpkg/MPC_LKResponse.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class MPC_LKResponse(genpy.Message):
  _md5sum = "63117583c3ceae63ea2c1910b9db9c41"
  _type = "rctestpkg/MPC_LKResponse"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """float64 s

"""
  __slots__ = ['s']
  _slot_types = ['float64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       s

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(MPC_LKResponse, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.s is None:
        self.s = 0.
    else:
      self.s = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      buff.write(_struct_d.pack(self.s))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      start = end
      end += 8
      (self.s,) = _struct_d.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      buff.write(_struct_d.pack(self.s))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      start = end
      end += 8
      (self.s,) = _struct_d.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_d = struct.Struct("<d")
class MPC_LK(object):
  _type          = 'rctestpkg/MPC_LK'
  _md5sum = '07ec41d26dcbce48a88bfe9b463548bd'
  _request_class  = MPC_LKRequest
  _response_class = MPC_LKResponse
